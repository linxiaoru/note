### 散列表
**散列表**（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。

**散列函数**将输入映射到数字。<br />
散列函数必须满足一些要求:
 - 它必须是一致的，同样的输入得到同样的输出。
 - 它将不同的输入映射到不同的数字。

散列函数的特点：
 - 散列函数总是将同样的输入映射到相同的索引。
 - 散列函数将不同的输入映射到不同的索引。
 - 散列函数知道数组有多大，只返回有效的索引。

 #### 冲突
 给两个键分配的位置相同，就产生冲突。<br />
 最简单的解决方案：如果两个键映射到了同一个位置，就在这个位置存储一个链表。

 散列函数很重要，好的散列函数很少导致冲突。

 在散列表中查找所花费的时间为常量时间。

|| 散列表（平均情况）|散列表（最糟情况）|数组|链表
-------|----------|-------|----------|----------
查找|O(1)|O(n)|O(1)|O(n)|
插入|O(1)|O(n)|O(n)|O(1)|
删除|O(1)|O(n)|O(n)|O(1)|

为了避免最糟情况，需要避免冲突，而避免冲突需要有：
- 较低的填装因子；
- 良好的散列函数。

#### 填装因子
散列表的填装因子的计算方式：<br />
    散列表包含的元素数 / 位置总数

散列表使用数组来存储数据，因此需要计算数组中被占用的位置数。

填装因子大于 1 意味着商品数量超过了数组的位置数。一旦填装因子开始增大，就需要在散列表中添加位置，这被称作**调整长度（resizing）**

填装因子越低，发生冲突的可能性越小，散列表的性能越高。

#### 良好的散列函数
良好的散列函数让数组中的值呈均匀分布。

糟糕的散列函数让值扎堆，导致大量的冲突 

####  小结
- 可以结合散列函数和数组来创建散列表
- 冲突很糟糕，应该使用可以最大限度减少冲突的散列函数
- 散列表的查找、插入和删除速度都非常快
- 散列表适合用于模拟映射关系
- 一旦填装因子超过 0.7，就该调整散列表的长度
- 散列表可用于缓存数据（例如，在Web服务器上）
- 散列表非常适合用于防止重复