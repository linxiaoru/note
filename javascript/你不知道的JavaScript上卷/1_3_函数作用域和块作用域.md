---
title: 第三章 函数作用域和块作用域
tags: javascript,作用域,闭包
notebook: 你不知道的JS上
---
#### 3.1 函数中的作用域
**函数作用域** 的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的 **“动态”** 特性。

#### 3.2 隐藏内部实现
**最小特权原则**：也叫最小授权或最小暴露原则，这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都 “隐藏” 起来，比如某个模块或对象的 API 设计。

例如：
```javascript
function doSomething(a) {
  b = a + doSomethingElse( a * 2 );

  console.log( b * 3 );
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething( 2 ); // 15 
```
变量 b 和函数 domeSomethingElse(...) 应该是 doSomething(...) 内部具体实现的 “私有” 内容。给予外部作用域对 b 和 doSomethingElse(...) 的 “访问权限” 不仅没有必要，而且可能是 “危险” 的，因为它们可能被有意或者无意地以非预期的方式使用，从而超出了 doSomething(...) 的适用条件。更 “合理” 的设计会将这些私有的具体内容隐藏在 doSomething(...) 内部，例如：
```javascript
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }

  var b;
  
  b = a + doSomethingElse( a * 2 );

  console.log( b * 3 );
}

doSomething( 2 ); // 15
```
现在，b 和 doSomethingElse(...) 都无法从外部被访问，而只能被 doSomething(...) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。

#### 规避冲突
“隐藏” 作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

##### 1、全局命名空间
变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果他们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的 **命名空间** ，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

例如：
```javascript
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function() {
    // ...
  },
  doAnotherThing: function() {
    // ...
  }
};
```

##### 2.模块管理
另一种避免冲突的办法和现代的 **模块** 机制和接近，就是从众多模块管理中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另一个特定的作用域中。 

#### 3.3 函数作用域
区分函数声明和函数表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

函数声明和函数表达式之间最重要的 ```区别``` 是它们的名称标识符将会绑定在何处。

(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。 foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

#### 3.3.1 匿名和具名
函数表达式可以是匿名的，而函数声明则不可以省略函数名--在 JavaScript 的语法中这是非法的。

匿名函数写法的代码 **缺点** ：
1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
2. 如果没有函数名，当函数需要引用自身时只能使用已经 ```过期的``` ```argument.callee``` 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

#### 3.3.2 立即执行函数表达式
```(function foo(){ ... })()``` ，第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。

**IIFE** 代表立即执行函数表达式(Immediately Invoked Function Expression)。

函数名对 **IIFE** 不是必须的， **IIFE** 最常见的用法是使用一个匿名函数表达式。 
```javascript
var a = 2;
(function IIFE() {

  var a = 3;
  console.log( a ); // 3

})();

console.log( a ); // 2
```

**IIFE** 的另一个非常普遍的进阶用法是把它们当做函数调用并传递参数进去。

例如：
```javascript
var a = 2;

(function IIFE( global ) {

  var a = 3;
  console.log( a ); //3
  console.log( global.a ); // 2
  
})( window );

console.log( a ); // 2
```

**IIFE** 还有一种变化用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 **IIFE** 执行```之后``` 当做参数传递进去。这种模式在 **UMD** ( Universal Module Definition ) 项目中被广泛使用。
```javascript
var a = 2;
(function IIFE( def ) {
  def( window );
})(function def( global ) {

  var a = 3;
  console.log( a ); //3
  console.log( global.a ); // 2

});
```

#### 3.4 块作用域
变量的声明应该距离使用的地方越近越好，并最大限度地本地化。

当使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。

**块作用域** 是一个用来对之前的 **最小授权** 原则进行扩展的工具，将代码从函数中隐藏信息扩展为块中隐藏信息。

#### 3.4.1 with
**with** 不仅是一个难于理解的结构，同时也是 ```块作用域``` 的一个例子（块作用域的一种形式）,用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。

#### 3.4.2 try/cath
ES3 规范中规定 try/cath 的 cath 分句会创建一个块作用域，其中声明的变量仅在 cath 内部有效。

例如：
```javascript
try {
  undefined();  // 执行一个非法操作来强制制造一个异常
}
cath (err) {
  console.log( err ); // 能够正常执行！
}

console.log( err ); // ReferenceError: err not found
```

当同一个作用域中的两个或多个 cath 分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会很烦人地发出警告。

#### 3.4.3 let
**let** 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let 为其声明的变量隐士地劫持了所在的块作用域。

显式的代码优于隐式或一些精巧但不清晰的代码。
```javascript
var foo = true;
if (foo) {
  { // <-- 显式的块
      let bar = foo * 2;
      bar = something( bar );
      console.log( bar );
  }
}

console.log( bar ); //ReferenceError
```
只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。

**提升** 是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。
```javascript
{
  console.log( bar ); // ReferenceError!
  let bar = 2;
}
```

#### 1.垃圾收集
为变量显示声明块作用域，并对变量进行本地绑定是非常有用的工具，可以更好地帮助引擎进行垃圾收集。

#### 2.let循环
```javascript
for (let i=0; i<10; i++) {
  console.log( i );
}

console.log( i ); // ReferenceError
```
for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其 ```重新绑定``` 到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

每次迭代时进行 **重新绑定** 的行为：
```javascript
{
  let j;
  for (j=0; j<10; j++) {
    let i = j;  // 每个迭代重新绑定！
    console.log( i );
  }
}
```

#### 3.4.4 const
ES6 还引入了 const, 同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

#### 3.5 小结
函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。

从 ES3 开始，try/cath 结构在 cath 分句中具有块作用域。

在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。```if(..) { let a = 2; }``` 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。 
