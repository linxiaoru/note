---
title: 第一章 作用域是什么
tags: javascript,作用域,闭包
notebook: 你不知道的JS上
---

#### 1.1 编译原理
 在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为 **“编译”**。
 -  **分词/词法分析（Tokenizing/Lexing）**
 这个过程会将有字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为 **词法单元（token）**
 例如, 
 ``` var a = 2;```
会被分解成下面这些词法单元
 ```var、a、 =、 2、;```
空格是否会被当做词法单元，取决于空格在这门语言中是否具有意义。
 
 -  **解析/语法分析（Parsing）**
 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为 **“抽象语法树(Abstract Syntax Tree，AST)”**。
 - **代码生成**
 将 AST 转换为可执行代码的过程被称为 **代码生成**。这个过程与语言、目标平台等息息相关。

任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。

#### 1.2 理解作用域
#### 1.2.1 演员表
- 引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。
- 编译器
引擎的好朋友之一，负责语法分析及代码生成等脏活累活。
- 作用域
负责收集并维护由所有声明的标识符（变量）组成的一些列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

#### 1.2.2 对话
`var a = 2;`
编译器会进行如下处理：
 1. 遇到 `var a` , 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则，它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 `a`。
 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 `a` 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 `a` 变量，就会将 `2` 赋值给它。否则引擎就会举手示意并抛出一个异常！

**总结：** 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

#### 1.2.3 编辑器有话说
|	查询类型			|		  含义  |	  理解方法 	|示例|
|  :------:  |  :------:  |  :------:  |	:------:	|
|  LHS  |  赋值操作的左侧  |  赋值操作的目标是谁(LHS)  |	```a = 2```, 这里对 ```a``` 的引用是 LHS 引用，并不关心当前的值是什么，只是想要为 ```= 2``` 这个赋值操作找到一个目标	|
|  RHS  |  赋值操作的右侧  |  谁是赋值操作的源头(RHS)  |	```console.log(a)```, 	这里对 ```a``` 的引用是一个 RHS 引用，因为 ```a``` 并没有赋予任何值。相应地，需要查找并取得 ```a```  的值，这样才能将值传递给 ```console.log(...)``` 。|

#### 1.2.5 测验
1.找到其中所有的 LHS 查询。（3处）
2.找到其中所有的 RHS 查询。（4处）

```javascript
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo(2);
```
LHS 查询：```c = ...;```、```a = 2 （隐式变量分配）```、```b = ...```
RHS 查询： ```foo(2..```、 ```= a;``` 、 ```a ..``` 、 ```.. b```

#### 1.3 作用域嵌套
**作用域** 是根据名称查找变量的一套规则。在实际情况中，通常需要同时顾及几个作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了 **作用域的嵌套** 。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

遍历嵌套作用域链的规则： 引擎从当前的执行作用域开始查找变量，如果找不到，就会向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

#### 1.4 异常
如果 **RHS查询** 在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 **ReferenceError** 异常。 

当引擎执行 **LHS查询** 时，如果在顶层（全局作用域）中也无法找到目标变量，*全局作用域* 中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在 **“非严格模式”**下。

**“严格模式”** 的一个特点是禁止自动或隐式地创建全局变量。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出 RHS 查询失败时类似的 **ReferenceError** 异常。

**TypeError**： 试图对一个非函数类型的值进行函数调用，或者引用 ```null``` 或 ```undefined``` 类型的值中的属性，那么引擎会抛出另一中类型的异常，叫做 **TypeError**。

```ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。```

#### 1.5 小结
作用域是一套规则， 用于确定在何处以及如何查找变量（标识符）。 如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询； 如果目的是获取变量的值， 就会使用 RHS 查询。
赋值操作会导致 LHS 查询。 = 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。